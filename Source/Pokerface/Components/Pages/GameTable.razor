@page "/joingametable/{SessionId:int}_{PlayerID:int}"

@inject NavigationManager Nav
@inject GameSessionService SessionService
@inject IJSRuntime JS

<PageTitle>Game Table</PageTitle>

<div class="gametable-wrapper">
    <div class="poker-table">

        <!-- Community cards -->
        <div class="community-cards">
            @for (int i = 0; i < CommunityCards.Count; i++)
            {
                <div class="card-spot"><PokerCard Model="CommunityCards[i]" /></div>
            }
        </div>

        <div class="players-top">
            @for (int chair = 1; chair <= 3; chair++)
            {
                <PlayerContainer
                    PlayerChair="chair"
                    Card1="@GetPlayerCard(chair).c1"
                    Card2="@GetPlayerCard(chair).c2"
                    Me="@Me"
                    PlayersByChair="@PlayersByChair" />
            }
        </div>

        <div class="players-bottom">
            @for (int chair = 5; chair <= 7; chair++)
            {
                <PlayerContainer
                    PlayerChair="chair"
                    Card1="@GetPlayerCard(chair).c1"
                    Card2="@GetPlayerCard(chair).c2"
                    Me="@Me"
                    PlayersByChair="@PlayersByChair" />
            }
        </div>

        <div class="player-pair-horizontal-right">    
            <PlayerContainer
                PlayerChair="4"
                Card1="@GetPlayerCard(4).c1"
                Card2="@GetPlayerCard(4).c2"
                Me="@Me"
                PlayersByChair="@PlayersByChair" />
        </div>
        <div class="player-pair-horizontal-left"> 
            <PlayerContainer
                PlayerChair="8"
                Card1="@GetPlayerCard(8).c1"
                Card2="@GetPlayerCard(8).c2"
                Me="@Me"
                PlayersByChair="@PlayersByChair" />
        </div>

    </div>

    <div class="table-actions-overlay">
        <button class="btn btn-primary"
                @onclick="StartGame"
                disabled="@NewGameDisabled">
            Starte Spiel
        </button>
        <button class="btn btn-primary" @onclick="(() => ExitGame(true))">Verlassen</button>
    </div>

    @if (Session != null && Session.CurrentGame != null)
    {
        <div class="action-mask-game">
            <div class="action-title">In Pot: @Session.CurrentGame.Pot</div>
            @foreach (var player in Session.CurrentGame.TheWinners ?? Enumerable.Empty<PlayerModel>())
            {
                <div class="action-title">@player.Name hat mit @player.Result gewonnen!</div>
            }
        </div>

        <div class="action-mask-player">
            <div class="action-panel">
                @if (Session.CurrentGame.RoundFinished)
                {
                    <div class="action-title">@Me?.Result</div>
                    <br />
                    <div class="bet-amount">My total stack: @Me?.RemainingStack</div>
                }
                else
                {
                    @if (Me?.IsNext == true)
                    {
                        @if (Session.AvailableActions != null)
                        {
                            <div class="action-title">@Me.Name</div>
                            <div class="action-buttons">
                                @foreach (var action in Session.AvailableActions)
                                {
                                    <button class="btn btn-action"
                                            @onclick="() => CommitAction(action)">
                                        @action.Label
                                    </button>
                                }
                            </div>

                            @if (Session.AvailableActions.Any(a => a.RequiredAmount > 0))
                            {
                                var minAmount = Session.AvailableActions
                                    .Where(a => a.RequiredAmount > 0)
                                    .Min(a => a.RequiredAmount);
                                var maxAmount = Math.Min(Me.RemainingStack, GetMaxBet());
                                if (SelectedAmount < minAmount) SelectedAmount = minAmount;

                                <input type="range"
                                       min="@minAmount"
                                       max="@maxAmount"
                                       step="5"
                                       @bind-value="SelectedAmount"
                                       @bind-value:event="oninput" />
                            }
                        }
                    }
                    else
                    {
                        <div class="action-title">Waiting for other players ...</div>
                    }

                    <div class="bet-amount">Bet: @SelectedAmount / Stack: @Me?.RemainingStack</div>
                }
            </div>
        </div>
    }
</div>

<MessageBox @ref="msgBox" />


@code {
    [Parameter] public int SessionId { get; set; }
    [Parameter] public int PlayerID { get; set; }

    private MessageBox? msgBox;

    private GameSessionModel? Session { get; set; }
    private PlayerModel? Me;
    private Dictionary<int, PlayerModel?> PlayersByChair = new();
    private int SelectedAmount = 0;

    private List<(PokerCardModel c1, PokerCardModel c2)> PlayerCards = new();
    private List<PokerCardModel> CommunityCards = new();

    public bool NewGameDisabled =>
        Session?.PlayersPending == null || Session.CurrentGame == null ||
        !(Session.PlayersPending.Count >= 2 && !Session.CurrentGame.RoundLocked);


    protected override void OnInitialized()
    {
        Session = SessionService.GetGameSessionById(SessionId);
        if (Session == null) return;

        Session.OnSessionChanged += Session_OnSessionChanged;
        Session.OnPlayerLost += Session_OnPlayerLost;

        Me = Session.GetPlayerById(PlayerID);

        // Initialize lists
        PlayerCards = Enumerable.Range(0, 8)
            .Select(_ => (new PokerCardModel(), new PokerCardModel()))
            .ToList();

        CommunityCards = Enumerable.Range(0, 5)
            .Select(_ => new PokerCardModel())
            .ToList();

        RebuildPlayersByChair();
        MapPlayerCards();
        MapCommunityCards();
    }

    private void Session_OnSessionChanged()
    {
        InvokeAsync(() =>
        {
            RebuildPlayersByChair();
            MapPlayerCards();
            MapCommunityCards();
            StateHasChanged();
        });
    }

    private void Session_OnPlayerLost(PlayerModel lostPlayer)
    {
        InvokeAsync(async () =>
        {
            if (Me == null || msgBox == null) return;

            if (lostPlayer == Me)
            {
                await msgBox.ShowAsync("### You Lost! ###",
                    "Da du zu wenig Geld hast, musst du das Spiel verlassen.\r\nDu kannst gerne nochmal beitreten!");
                await ExitGame(false);
                return;
            }

            await msgBox.ShowAsync("### Player Lost! ###",
                $"Der Spieler {lostPlayer.Name} hatte zu wenig Geld und musste das Spiel verlassen!");

            RebuildPlayersByChair();
            MapPlayerCards();
            MapCommunityCards();
            StateHasChanged();
        });
    }

    private void RebuildPlayersByChair()
    {
        if (Session == null || Session.PlayersPending == null) 
        return;

        PlayersByChair = new Dictionary<int, PlayerModel?>();

        for (int chair = 0; chair < TableModel.MaxPlayers; chair++)
        {
            PlayersByChair[chair] = Session.PlayersPending.Where(x => x.Chair == chair).FirstOrDefault();
        }
    }


    private void MapPlayerCards()
    {
        if (Session?.CurrentGame == null || Me == null) return;

        for (int chair = 1; chair <= TableModel.MaxPlayers; chair++)
        {
            if (!PlayersByChair.TryGetValue(chair, out var player) || player == null) continue;

            bool showFace = player == Me || Session.CurrentGame.CurrentRound == BettingRound.Showdown;

            var (c1, c2) = GetPlayerCard(chair);
            if (player.Card1 != null) c1.SetCard(player.Card1, showFace);
            if (player.Card2 != null) c2.SetCard(player.Card2, showFace);
        }
    }

    private void MapCommunityCards()
    {
        if (Session?.CommunityCards == null) return;

        for (int i = 0; i < CommunityCards.Count; i++)
        {
            if (Session.CommunityCards.Count > i)
                CommunityCards[i].SetCard(Session.CommunityCards[i], true);
            else
                CommunityCards[i].HideCard();
        }
    }

    private void ClearAllCards()
    {
        foreach (var card in CommunityCards) card.HideCard();
        foreach (var pair in PlayerCards)
        {
            pair.c1.HideCard();
            pair.c2.HideCard();
        }
    }

    private async Task StartGame()
    {
        if (Session?.CurrentGame == null || Me == null) return;

        ClearAllCards();
        await Session.StartGame();

        PlayersByChair = Enumerable.Range(1, 8)
            .ToDictionary(chair => chair,
                chair => Session.CurrentGame.Players.FirstOrDefault(p => p.Chair == chair));
    }

    private async Task ExitGame(bool deletePlayer)
    {
        if (Session != null && Me != null)
        {
            Session.OnSessionChanged -= Session_OnSessionChanged;
            Session.OnPlayerLost -= Session_OnPlayerLost;

            if (deletePlayer) await SessionService.RemovePlayerFromSessionAsync(Session, Me);
        }

        Nav.NavigateTo("/tables");
    }

    private void CommitAction(ActionOption option)
    {
        if (Session == null || Me == null || !Me.IsNext) return;

        option.SelectedAmount = SelectedAmount;
        Me.TakeAction(option);
    }

    private int GetMaxBet()
    {
        if (Session?.CurrentGame == null || Me == null) throw new ArgumentNullException();

        int max = Math.Min(Me.RemainingStack, Session.CurrentGame.MaxBet);
        if (SelectedAmount < Session.CurrentGame.MinBet) SelectedAmount = Session.CurrentGame.MinBet;
        if (SelectedAmount > max) SelectedAmount = max;
        return max;
    }

    private (PokerCardModel c1, PokerCardModel c2) GetPlayerCard(int chair) =>
        PlayerCards[chair - 1]; // chairs 1–8 map to index 0–7
}
